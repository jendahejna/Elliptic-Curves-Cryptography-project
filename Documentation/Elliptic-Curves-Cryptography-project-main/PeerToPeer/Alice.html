<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice API documentation</title>
<meta name="description" content="Alice peer file â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice</code></h1>
</header>
<section id="section-intro">
<p>Alice peer file.</p>
<h2 id="functions">Functions</h2>
<p>derive_key:
Derives a key for AES encryption from the shared key of this peer.
create_encryptor_decryptor: Creates encryptor and decryptor objects using the derived key and an IV.
send_messages:
Sends encrypted and signed messages or files from the user over a given connection.
receive_messages:
Receives, decrypts, and verifies encrypted messages or files over a given connection.
exchange_keys:
Exchanges ECDH public keys and establishes encryption.
exchange_signature_keys:
Exchange signature public keys between two communication parties.
attempt_connection:
Attempts to establish a connection to a specified target using the given socket.
create_server:
Creates a server socket, binds it to a local address, listens for incoming connections.
main:
Demonstrates created functions and their implementation.</p>
<h2 id="authors">Authors</h2>
<p>Jan Hejna, 221545
Daniel Kluka, 203251
Jan Rezek, 227374
Michal Rosa, 221012</p>
<h2 id="documentation">Documentation</h2>
<p>Documentation is auto-generated and can be found in Documentation folders.
Documentation authors:
Daniel Kluka, 203251
Michal Rosa, 221012</p>
<h2 id="version">Version</h2>
<p>5.0.1</p>
<h2 id="date">Date</h2>
<p>20.4.2024</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Alice peer file.

Functions:
    derive_key:                 Derives a key for AES encryption from the shared key of this peer.
    create_encryptor_decryptor: Creates encryptor and decryptor objects using the derived key and an IV.
    send_messages:              Sends encrypted and signed messages or files from the user over a given connection.
    receive_messages:           Receives, decrypts, and verifies encrypted messages or files over a given connection.
    exchange_keys:              Exchanges ECDH public keys and establishes encryption.
    exchange_signature_keys:    Exchange signature public keys between two communication parties.
    attempt_connection:         Attempts to establish a connection to a specified target using the given socket.
    create_server:              Creates a server socket, binds it to a local address, listens for incoming connections.
    main:                       Demonstrates created functions and their implementation.

Authors:
    Jan Hejna, 221545
    Daniel Kluka, 203251
    Jan Rezek, 227374
    Michal Rosa, 221012

Documentation:
    Documentation is auto-generated and can be found in Documentation folders.
    Documentation authors:
        Daniel Kluka, 203251
        Michal Rosa, 221012

Version:
    5.0.1

Date:
    20.4.2024
&#34;&#34;&#34;
import socket
import threading
import os
from Protocols import ECDH

from cryptography.hazmat.primitives.asymmetric import ec, ed25519
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from Protocols.signature import key_generation, sign_message, verify_signature
from Protocols.ECIES import derive_encryption_parameters, encryption_chacha, encryption_aes, decrypt_message_aes, \
    decrypt_message_chacha
import logging


&#34;&#34;&#34;
Logger.

Function: 
    Logs and saves important actions and informations during peer to peer communication.

Author: 
    Daniel Kluka, 203251
&#34;&#34;&#34;
log_directory = &#34;./Logs&#34;
log_filename = &#34;alice_peer.log&#34;

if not os.path.exists(log_directory):
    os.makedirs(log_directory)

log_path = os.path.join(log_directory, log_filename)

logging.basicConfig(level=logging.DEBUG,
                    format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;,
                    datefmt=&#39;%Y-%m-%d %H:%M:%S&#39;,
                    filename=log_path,
                    filemode=&#39;w&#39;)
logger = logging.getLogger(&#39;AlicePeer&#39;)


def derive_key(shared_key):
    &#34;&#34;&#34;
    Derives a key for AES encryption from the shared key of this peer.

    Args:
        shared_key: Shared key of this peer.

    Author:
        Jan Rezek, 227374
    &#34;&#34;&#34;
    return HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b&#39;handshake data&#39;
    ).derive(shared_key)


def create_encryptor_decryptor(key, iv=None):
    &#34;&#34;&#34;
    Creates encryptor and decryptor objects using the derived key and an IV.
    If IV is None, generates a new one, otherwise uses the provided IV.

    Args:
        key:    Derived key from shared key.
        iv:     Initialization vector for increased security.

    Returns:
        encryptor:  Data encryptor object.
        decryptor:  Data decryptor object.
        iv:         Initialization vector.

    Authors:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    if iv is None:
        iv = os.urandom(16)
        logger.debug(&#34;Generated new IV for AES encryption.&#34;)
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
    return cipher.encryptor(), cipher.decryptor(), iv


def send_messages(connection, peer_name, alice_shared_key, ecies_type, signature_priv_key, signature_name):
    &#34;&#34;&#34;
    Sends encrypted and signed messages or files from the user over a given connection.

    Args:
        connection:         The communication channel used to send encrypted messages.
        peer_name:          Name of this peer.
        alice_shared_key:   The shared secret key derived during the cryptographic session initialization, used for
                            encrypting message.
        ecies_type:         The type of symmetric encryption used in the ECIES scheme (AES, ChaCha).
        signature_priv_key: Private key of this peer.
        signature_name:     Specifies the type of signature scheme (ECDSA, EdDSA)

    Returns:
        The function returns None as it is designed to run indefinitely until
        the user decides to quit the messaging session.

    Exceptions:
        The function will catch and print any exceptions raised during the message
        sending process, mainly focusing on connection issues.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
        Jan Rezek, 227374
        Michal Rosa, 221012
    &#34;&#34;&#34;
    separator = b&#34;||&#34;
    files_to_send_dir = &#34;./Files/FilesToSend/&#34;
    received_files_dir = &#34;./Files/ReceivedFiles/&#34;
    os.makedirs(received_files_dir, exist_ok=True)

    while True:
        command = input(&#34;Enter your message or type &#39;sendFile&#39; to send a file: &#34;)
        logger.debug(f&#34;User input message: {command}&#34;)

        if command.lower() == &#39;quit&#39;:
            connection.send(b&#39;quit&#39;)
            logger.info(&#34;User initiated quit.&#34;)
            break

        if command.lower() == &#39;sendfile&#39;:
            logger.info(&#34;User wants to send file&#34;)
            filename = input(&#34;Enter the filename to send: &#34;)
            filepath = os.path.join(files_to_send_dir, filename)
            if os.path.exists(filepath):
                logger.info(f&#34;File path: {filepath}&#34;)
                with open(filepath, &#39;rb&#39;) as f:
                    file_data = f.read()
                file_message = f&#34;FILE::{filename}||&#34;.encode() + file_data
                connection.send(file_message)
                logger.info(f&#34;Sent file: {filename}&#34;)
                print(f&#34;Sent file: {filename}&#34;)
            else:
                logger.warning(f&#34;File not found: {filename}&#34;)
                print(f&#34;File not found: {filename}&#34;)
            continue

        # Encode the full message
        full_message = f&#34;{peer_name}: {command}&#34;.encode(&#39;utf-8&#39;)

        # Sign the message
        signature = sign_message(signature_priv_key, full_message, signature_name)

        # Encrypt the entire message including the signature
        if ecies_type == &#34;ChaCha&#34;:
            ecies_key, hmac_key = derive_encryption_parameters(alice_shared_key)
            nonce, encrypted_message, mac = encryption_chacha(ecies_key, hmac_key, full_message)
            final_message = nonce + separator + encrypted_message + separator + signature
        elif ecies_type == &#34;AES&#34;:
            ecies_key, hmac_key = derive_encryption_parameters(alice_shared_key)
            iv, encrypted_message, mac = encryption_aes(ecies_key, hmac_key, full_message)
            final_message = iv + separator + encrypted_message + separator + signature

        try:
            connection.send(final_message)
            logger.debug(f&#34;Sent encrypted and signed message: {encrypted_message.hex()}&#34;)
            print(f&#34;Sent encrypted message: {final_message.hex()}&#34;)
        except Exception as e:
            logger.error(f&#34;Failed to send message. Error: {e}&#34;, exc_info=True)
            print(&#34;Failed to send message. Error:&#34;, e)
            break


def receive_messages(connection, alice_shared_key, ecies_type, signature_pub_key, signature_name):
    &#34;&#34;&#34;
    Receives, decrypts, and verifies encrypted messages or files over a given connection.

    Parameters:
        connection:         The communication channel used to receive encrypted messages.
        alice_shared_key:   The shared secret key derived during the cryptographic session initialization, used for
                            decrypting the encrypted message.
        ecies_type:         The type of symmetric encryption used in the ECIES scheme (AES, ChaCha).
        signature_pub_key:  Public key of other peer.
        signature_name:     Specifies the type of signature scheme (ECDSA, EdDSA)

    Exceptions:
        General exception handling to catch and handle unexpected errors.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
        Jan Rezek, 227374
        Michal Rosa, 221012
    &#34;&#34;&#34;
    separator = b&#34;||&#34;
    received_files_dir = &#34;Files/ReceivedFiles/&#34;
    os.makedirs(received_files_dir, exist_ok=True)
    while True:
        try:
            encrypted_message = connection.recv(2048)  # Suggested buffer size for adequate capacity
            logger.info(f&#34;Received encrypted message: {encrypted_message.hex()}&#34;)
            print(f&#34;Received encrypted message: {encrypted_message.hex()}&#34;)

            parts = encrypted_message.split(separator)
            if len(parts) == 3:
                nonce_iv, ciphertext, signature = parts

                # Decrypt the message
                if ecies_type == &#34;ChaCha&#34;:
                    ecies_key, hmac_key = derive_encryption_parameters(alice_shared_key)
                    message = decrypt_message_chacha(ecies_key, nonce_iv, ciphertext)
                elif ecies_type == &#34;AES&#34;:
                    aes_key, hmac_key = derive_encryption_parameters(alice_shared_key)
                    message = decrypt_message_aes(aes_key, nonce_iv, ciphertext)

                # Verify the signature
                if message and verify_signature(signature_pub_key, message, signature, signature_name):
                    logger.info(f&#34;Decrypted and verified message: {message.decode(&#39;utf-8&#39;)}&#34;)
                    print(f&#34;Decrypted and verified message: {message.decode(&#39;utf-8&#39;)}&#34;)
                else:
                    logger.error(&#34;Failed to verify message signature.&#34;)
                    print(&#34;Failed to verify message signature or message is None.&#34;)
            elif len(parts) == 2:
                # File messages assumed to be in the format: FILE::filename||filedata
                filename = parts[0].split(b&#34;::&#34;)[1].decode()
                file_data = parts[1]
                filepath = os.path.join(received_files_dir, filename)
                with open(filepath, &#39;wb&#39;) as f:
                    f.write(file_data)
                logger.info(f&#34;Received and saved file: {filename}&#34;)
                print(f&#34;Received and saved file: {filename}&#34;)
            else:
                logger.warning(&#34;Invalid message format, parts count: &#34;, len(parts))
                print(&#34;Invalid message format, parts count: &#34;, len(parts))
        except Exception as e:
            logger.error(f&#34;Connection lost. Error: {e}&#34;, exc_info=True)
            print(&#34;Connection lost. Error:&#34;, e)
            break


def exchange_keys(connection, alice_priv_key, is_server):
    &#34;&#34;&#34;
    Exchanges public keys and establishes encryption.

    Args:
        connection:     The communication channel used to send and receive public keys.
        alice_priv_key: Alice&#39;s private key used to generate her public key and to compute the shared ECDH key.
        is_server:      A flag indicating whether the caller is the server or client.

    Returns:
        tuple:  A tuple containing the encryptor, decryptor, and Bob&#39;s public key:
            encryptor:      Used to encrypt messages.
            decryptor:      Used to decrypt received messages.
            bob_pub_key:    Bob&#39;s public key for signature verification.

    Exceptions:
        This function handles connection and serialization errors internally, primarily
        during the key exchange or IV management phases. Any exceptions will cause
        an appropriate error message to be printed and will terminate the execution.

    Author:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    alice_pub_key = alice_priv_key.public_key()
    public_key_bytes = ECDH.serialize_pub_key(alice_pub_key)
    if is_server:
        # Server sends first, then receives
        connection.send(public_key_bytes)
        peer_public_key_bytes = connection.recv(1024)
        logger.info(&#34;Alice connected as server for ECDH key exchange.&#34;)
    else:
        # Client receives first, then sends
        peer_public_key_bytes = connection.recv(1024)
        connection.send(public_key_bytes)
        logger.info(&#34;Alice connected as client for ECDH key exchange.&#34;)

    bob_pub_key = serialization.load_pem_public_key(peer_public_key_bytes)
    alice_shared_key = ECDH.shared_ecdh_key(alice_priv_key, bob_pub_key)
    logger.debug(f&#34;Alice generated shared key: {alice_shared_key.hex()}&#34;)

    # Serialize the shared key for transmission
    shared_key_bytes = alice_shared_key.hex().encode(&#39;utf-8&#39;)

    # Exchange the shared key
    if is_server:
        # Server sends the shared key
        connection.send(shared_key_bytes)
        peer_shared_key_bytes = connection.recv(1024)
        logger.info(&#34;Alice received Bob&#39;s shared key.&#34;)
    else:
        peer_shared_key_bytes = connection.recv(1024)
        # Client sends the shared key
        connection.send(shared_key_bytes)
        logger.info(&#34;Alice sends shared key to Bob.&#34;)

    # Confirm that both shared keys match (optional step for additional security)
    if shared_key_bytes != peer_shared_key_bytes:
        logger.error(&#34;Shared keys do not match!&#34;, exc_info=True)
        raise ValueError(&#34;Shared keys do not match!&#34;)

    base_dir = &#34;../Keys/ECDH/Alice&#34;
    os.makedirs(base_dir, exist_ok=True)
    ECDH.save_ecdh_keys(alice_pub_key, alice_shared_key, base_dir)
    logger.info(&#34;ECDH keys saved at: &#34; + base_dir)

    key = derive_key(alice_shared_key)
    encryptor, decryptor, iv = create_encryptor_decryptor(key)

    if is_server:
        # Server sends IV
        connection.send(iv)
        logger.info(&#34;Alice sends IV.&#34;)
    else:
        # Client receives IV
        iv = connection.recv(16)
        logger.debug(&#34;Alice receives and uses IV.&#34;)
        # Use existing IV
        encryptor, decryptor, _ = create_encryptor_decryptor(key, iv)
    return encryptor, decryptor, bob_pub_key, alice_shared_key


def exchange_signature_keys(connection, local_signature_pub_key, is_server):
    &#34;&#34;&#34;
    Exchange signature public keys between two communication parties.

    Args:
        connection:                 Active socket connection for data exchange.
        local_signature_pub_key:    Local user&#39;s public key.
        is_server:                  Indicates if the local party is the server (True) or the client (False). If True,
                                    sends first and receives second; if False, receives first and sends second.

    Returns:
        peer_signature_pub_key: The remote party&#39;s public key, deserialized from PEM format, for verifying signatures.

    Raises:
        TypeError: If `local_signature_pub_key` is not the correct type, indicating an invalid key.

    Notes:
        Keys are transmitted in PEM format and deserialized upon receipt to maintain cryptographic integrity and
        operability.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
    &#34;&#34;&#34;
    if not isinstance(local_signature_pub_key, (ec.EllipticCurvePublicKey, ed25519.Ed25519PublicKey)):
        logger.error(&#34;Provided public key is not a valid public key object.&#34;, exc_info=True)
        raise TypeError(&#34;Provided public key is not a valid public key object.&#34;)

    local_pub_key_bytes = ECDH.serialize_pub_key(local_signature_pub_key)

    if is_server:
        # Server sends first, then receives
        connection.send(local_pub_key_bytes)
        peer_pub_key_bytes = connection.recv(1024)
        logger.info(&#34;Alice connected as server for signature exchange.&#34;)
    else:
        # Client receives first, then sends
        peer_pub_key_bytes = connection.recv(1024)
        connection.send(local_pub_key_bytes)
        logger.info(&#34;Alice connected as client for signature exchange.&#34;)

    # Convert received bytes back to public key
    peer_signature_pub_key = serialization.load_pem_public_key(peer_pub_key_bytes)
    logger.debug(&#34;Received peer signature public key.&#34;)
    return peer_signature_pub_key


def attempt_connection(peer_socket, target=(&#39;localhost&#39;, 8080)):
    &#34;&#34;&#34;
    Attempts to establish a connection to a specified target using the given socket.

    Args:
        peer_socket:    The socket object configured for network communication.
        target:         A tuple containing the target host address and port number.

    Returns:
        Returns True if the connection is successfully established, False if not.

    Exceptions:
        This function catches this specific exception to return False.

    Authors:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    try:
        peer_socket.connect(target)
        logger.debug(&#34;Attempted connection to localhost.&#34;)
        return True
    except ConnectionRefusedError:
        logger.error(&#34;Failed to create server or accept connection.&#34;, exc_info=True)
        return False


def create_server():
    &#34;&#34;&#34;
    Creates a server socket, binds it to a local address, and listens for incoming client connections.

    Returns:
        socket: Returns the client connection socket object, which can be used to send and receive data.

    Exceptions:
        Socket-related exceptions can occur during socket creation, binding, listening, or accepting connections.

    Authors:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((&#39;localhost&#39;, 8080))
    server_socket.listen(1)
    logger.info(&#34;Alice is waiting for a connection on port 8080.&#34;)
    print(&#34;Waiting for connection on port 8080.&#34;)
    connection, address = server_socket.accept()
    logger.info(f&#34;Connection established with Bob at {address}&#34;)
    print(f&#34;Connection established with Bob {address}&#34;)
    return connection


def main():
    &#34;&#34;&#34;
    Initializes and runs the main functionality for Alice&#39;s side of a secure chat application.

    This function handles the setup and management of a peer-to-peer (P2P) encrypted chat session
    using elliptic curve cryptography (ECC) for secure key exchange and message encryption.

    Steps:
        1. Sets up Alice&#39;s identity and creates a socket for network communication.
        2. Prompts the user to enter the name of the elliptic curve for key generation.
        3. Prompts the user to enter the name of the algorithm for digital signature.
        4. Prompts the user to enter the name encryption method for ECIES.
        5. Prompts the user to enter the new file password for file encryption.
        6. Attempts to establish a connection with Bob:
            - If a connection is not initially established, it assumes the role of server and waits for a client.
            - If connected, it assumes the role of client.
        7. Exchanges public keys and establishes encryption parameters including encryptor and decryptor.
        8. Starts separate threads for sending and receiving encrypted messages or files.
        9. Waits for both threads to finish, which occurs when the chat session ends.
        10. Closes the network socket and prints a message indicating the end of the chat.
        11. Saves log that was created during peer to peer communication.

    The user is responsible for specifying the correct elliptic curve name that must be agreed upon by both peers.
    The user is also responsible for choosing algorithm of digital signature, encryption method and file password,
    which must be agreed on the same way.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
        Jan Rezek, 227374
        Michal Rosa, 221012
    &#34;&#34;&#34;
    print(&#34;Peer name: Alice&#34;)
    peer_name = &#34;Alice&#34;
    peer_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    peer_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    curve_name = input(&#34;Enter the ECDH curve name, must be the same for both peers (e.g., SECP384R1, SECP521R1): &#34;)
    signature_name = input(&#34;Enter algorithm for digital signature (e.g., ECDSA, EdDSA): &#34;)
    ecies_type = input(&#34;Enter encryption method for ECIES (e.g., ChaCha, AES): &#34;)
    logger.info(&#34;User selected: &#34; + curve_name + &#34;, &#34; + signature_name + &#34;, &#34; + ecies_type)

    password = input(&#34;Choose new key file password: &#34;)
    logger.info(&#34;User password for key file: &#34; + password)

    logger.info(&#34;Generating ECDH keys.&#34;)
    alice_priv_key, alice_pub_key = ECDH.generate_ecdh_keys(curve_name)
    logger.debug(&#34;Generated ECDH Alice private key and public key.&#34;)

    if not attempt_connection(peer_socket):
        # Act as server
        is_server = True
        peer_socket = create_server()
        logger.info(&#34;Server created.&#34;)
    else:
        # Connected as client
        is_server = False
        logger.info(&#34;Connected to Bob.&#34;)
        print(&#34;Connected to Bob.&#34;)

    logger.info(&#34;Exchanging ECDH keys.&#34;)
    encryptor, decryptor, bob_pub_key, alice_shared_key = exchange_keys(peer_socket, alice_priv_key, is_server)
    logger.debug(&#34;Exchanged ECDH keys.&#34;)

    logger.info(&#34;Generating and encrypting Alice&#39;s signature keys.&#34;)
    signature_private_key, signature_public_key = key_generation(signature_name, &#39;alice_priv.pem&#39;, &#39;alice_pub.pem&#39;,
                                                                 password)
    logger.debug(&#34;Generated and encrypted Alice&#39;s signature keys.&#34;)

    logger.info(&#34;Exchanging signature keys.&#34;)
    peer_signature_pub_key = exchange_signature_keys(peer_socket, signature_public_key, is_server)
    logger.debug(&#34;Exchanged signature keys.&#34;)

    logger.info(&#34;Starting receiver and sender threads.&#34;)
    receiver_thread = threading.Thread(target=receive_messages,
                                       args=(peer_socket, alice_shared_key, ecies_type, peer_signature_pub_key,
                                             signature_name))
    sender_thread = threading.Thread(target=send_messages,
                                     args=(peer_socket, peer_name, alice_shared_key, ecies_type, signature_private_key,
                                           signature_name))
    logger.info(&#34;Started receiver and sender threads.&#34;)

    receiver_thread.start()
    sender_thread.start()

    receiver_thread.join()
    sender_thread.join()

    peer_socket.close()
    print(&#34;Chat ended.&#34;)


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.attempt_connection"><code class="name flex">
<span>def <span class="ident">attempt_connection</span></span>(<span>peer_socket, target=('localhost', 8080))</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to establish a connection to a specified target using the given socket.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>peer_socket</code></strong></dt>
<dd>The socket object configured for network communication.</dd>
<dt><strong><code>target</code></strong></dt>
<dd>
<pre><code>A tuple containing the target host address and port number.
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Returns True if the connection is successfully established, False if not.</p>
<h2 id="exceptions">Exceptions</h2>
<p>This function catches this specific exception to return False.</p>
<h2 id="authors">Authors</h2>
<p>Daniel Kluka, 203251
Jan Rezek, 227374</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attempt_connection(peer_socket, target=(&#39;localhost&#39;, 8080)):
    &#34;&#34;&#34;
    Attempts to establish a connection to a specified target using the given socket.

    Args:
        peer_socket:    The socket object configured for network communication.
        target:         A tuple containing the target host address and port number.

    Returns:
        Returns True if the connection is successfully established, False if not.

    Exceptions:
        This function catches this specific exception to return False.

    Authors:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    try:
        peer_socket.connect(target)
        logger.debug(&#34;Attempted connection to localhost.&#34;)
        return True
    except ConnectionRefusedError:
        logger.error(&#34;Failed to create server or accept connection.&#34;, exc_info=True)
        return False</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.create_encryptor_decryptor"><code class="name flex">
<span>def <span class="ident">create_encryptor_decryptor</span></span>(<span>key, iv=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates encryptor and decryptor objects using the derived key and an IV.
If IV is None, generates a new one, otherwise uses the provided IV.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>Derived key from shared key.</dd>
<dt><strong><code>iv</code></strong></dt>
<dd>
<p>Initialization vector for increased security.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>encryptor</code></dt>
<dd>Data encryptor object.</dd>
<dt><code>decryptor</code></dt>
<dd>Data decryptor object.</dd>
<dt><code>iv</code></dt>
<dd>
<pre><code>Initialization vector.
</code></pre>
</dd>
</dl>
<h2 id="authors">Authors</h2>
<p>Daniel Kluka, 203251
Jan Rezek, 227374</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_encryptor_decryptor(key, iv=None):
    &#34;&#34;&#34;
    Creates encryptor and decryptor objects using the derived key and an IV.
    If IV is None, generates a new one, otherwise uses the provided IV.

    Args:
        key:    Derived key from shared key.
        iv:     Initialization vector for increased security.

    Returns:
        encryptor:  Data encryptor object.
        decryptor:  Data decryptor object.
        iv:         Initialization vector.

    Authors:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    if iv is None:
        iv = os.urandom(16)
        logger.debug(&#34;Generated new IV for AES encryption.&#34;)
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
    return cipher.encryptor(), cipher.decryptor(), iv</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.create_server"><code class="name flex">
<span>def <span class="ident">create_server</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a server socket, binds it to a local address, and listens for incoming client connections.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>socket</code></dt>
<dd>Returns the client connection socket object, which can be used to send and receive data.</dd>
</dl>
<h2 id="exceptions">Exceptions</h2>
<p>Socket-related exceptions can occur during socket creation, binding, listening, or accepting connections.</p>
<h2 id="authors">Authors</h2>
<p>Daniel Kluka, 203251
Jan Rezek, 227374</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_server():
    &#34;&#34;&#34;
    Creates a server socket, binds it to a local address, and listens for incoming client connections.

    Returns:
        socket: Returns the client connection socket object, which can be used to send and receive data.

    Exceptions:
        Socket-related exceptions can occur during socket creation, binding, listening, or accepting connections.

    Authors:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((&#39;localhost&#39;, 8080))
    server_socket.listen(1)
    logger.info(&#34;Alice is waiting for a connection on port 8080.&#34;)
    print(&#34;Waiting for connection on port 8080.&#34;)
    connection, address = server_socket.accept()
    logger.info(f&#34;Connection established with Bob at {address}&#34;)
    print(f&#34;Connection established with Bob {address}&#34;)
    return connection</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.derive_key"><code class="name flex">
<span>def <span class="ident">derive_key</span></span>(<span>shared_key)</span>
</code></dt>
<dd>
<div class="desc"><p>Derives a key for AES encryption from the shared key of this peer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shared_key</code></strong></dt>
<dd>Shared key of this peer.</dd>
</dl>
<h2 id="author">Author</h2>
<p>Jan Rezek, 227374</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derive_key(shared_key):
    &#34;&#34;&#34;
    Derives a key for AES encryption from the shared key of this peer.

    Args:
        shared_key: Shared key of this peer.

    Author:
        Jan Rezek, 227374
    &#34;&#34;&#34;
    return HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b&#39;handshake data&#39;
    ).derive(shared_key)</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.exchange_keys"><code class="name flex">
<span>def <span class="ident">exchange_keys</span></span>(<span>connection, alice_priv_key, is_server)</span>
</code></dt>
<dd>
<div class="desc"><p>Exchanges public keys and establishes encryption.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong></dt>
<dd>
<p>The communication channel used to send and receive public keys.</p>
</dd>
<dt><strong><code>alice_priv_key</code></strong></dt>
<dd>Alice's private key used to generate her public key and to compute the shared ECDH key.</dd>
<dt><strong><code>is_server</code></strong></dt>
<dd>
<p>A flag indicating whether the caller is the server or client.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing the encryptor, decryptor, and Bob's public key:
encryptor:
Used to encrypt messages.
decryptor:
Used to decrypt received messages.
bob_pub_key:
Bob's public key for signature verification.</dd>
</dl>
<h2 id="exceptions">Exceptions</h2>
<p>This function handles connection and serialization errors internally, primarily
during the key exchange or IV management phases. Any exceptions will cause
an appropriate error message to be printed and will terminate the execution.</p>
<h2 id="author">Author</h2>
<p>Daniel Kluka, 203251
Jan Rezek, 227374</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exchange_keys(connection, alice_priv_key, is_server):
    &#34;&#34;&#34;
    Exchanges public keys and establishes encryption.

    Args:
        connection:     The communication channel used to send and receive public keys.
        alice_priv_key: Alice&#39;s private key used to generate her public key and to compute the shared ECDH key.
        is_server:      A flag indicating whether the caller is the server or client.

    Returns:
        tuple:  A tuple containing the encryptor, decryptor, and Bob&#39;s public key:
            encryptor:      Used to encrypt messages.
            decryptor:      Used to decrypt received messages.
            bob_pub_key:    Bob&#39;s public key for signature verification.

    Exceptions:
        This function handles connection and serialization errors internally, primarily
        during the key exchange or IV management phases. Any exceptions will cause
        an appropriate error message to be printed and will terminate the execution.

    Author:
        Daniel Kluka, 203251
        Jan Rezek, 227374
    &#34;&#34;&#34;
    alice_pub_key = alice_priv_key.public_key()
    public_key_bytes = ECDH.serialize_pub_key(alice_pub_key)
    if is_server:
        # Server sends first, then receives
        connection.send(public_key_bytes)
        peer_public_key_bytes = connection.recv(1024)
        logger.info(&#34;Alice connected as server for ECDH key exchange.&#34;)
    else:
        # Client receives first, then sends
        peer_public_key_bytes = connection.recv(1024)
        connection.send(public_key_bytes)
        logger.info(&#34;Alice connected as client for ECDH key exchange.&#34;)

    bob_pub_key = serialization.load_pem_public_key(peer_public_key_bytes)
    alice_shared_key = ECDH.shared_ecdh_key(alice_priv_key, bob_pub_key)
    logger.debug(f&#34;Alice generated shared key: {alice_shared_key.hex()}&#34;)

    # Serialize the shared key for transmission
    shared_key_bytes = alice_shared_key.hex().encode(&#39;utf-8&#39;)

    # Exchange the shared key
    if is_server:
        # Server sends the shared key
        connection.send(shared_key_bytes)
        peer_shared_key_bytes = connection.recv(1024)
        logger.info(&#34;Alice received Bob&#39;s shared key.&#34;)
    else:
        peer_shared_key_bytes = connection.recv(1024)
        # Client sends the shared key
        connection.send(shared_key_bytes)
        logger.info(&#34;Alice sends shared key to Bob.&#34;)

    # Confirm that both shared keys match (optional step for additional security)
    if shared_key_bytes != peer_shared_key_bytes:
        logger.error(&#34;Shared keys do not match!&#34;, exc_info=True)
        raise ValueError(&#34;Shared keys do not match!&#34;)

    base_dir = &#34;../Keys/ECDH/Alice&#34;
    os.makedirs(base_dir, exist_ok=True)
    ECDH.save_ecdh_keys(alice_pub_key, alice_shared_key, base_dir)
    logger.info(&#34;ECDH keys saved at: &#34; + base_dir)

    key = derive_key(alice_shared_key)
    encryptor, decryptor, iv = create_encryptor_decryptor(key)

    if is_server:
        # Server sends IV
        connection.send(iv)
        logger.info(&#34;Alice sends IV.&#34;)
    else:
        # Client receives IV
        iv = connection.recv(16)
        logger.debug(&#34;Alice receives and uses IV.&#34;)
        # Use existing IV
        encryptor, decryptor, _ = create_encryptor_decryptor(key, iv)
    return encryptor, decryptor, bob_pub_key, alice_shared_key</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.exchange_signature_keys"><code class="name flex">
<span>def <span class="ident">exchange_signature_keys</span></span>(<span>connection, local_signature_pub_key, is_server)</span>
</code></dt>
<dd>
<div class="desc"><p>Exchange signature public keys between two communication parties.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong></dt>
<dd>
<pre><code>        Active socket connection for data exchange.
</code></pre>
</dd>
<dt><strong><code>local_signature_pub_key</code></strong></dt>
<dd>Local user's public key.</dd>
<dt><strong><code>is_server</code></strong></dt>
<dd>
<pre><code>         Indicates if the local party is the server (True) or the client (False). If True,
                sends first and receives second; if False, receives first and sends second.
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>peer_signature_pub_key</code></dt>
<dd>The remote party's public key, deserialized from PEM format, for verifying signatures.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>local_signature_pub_key</code> is not the correct type, indicating an invalid key.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Keys are transmitted in PEM format and deserialized upon receipt to maintain cryptographic integrity and
operability.</p>
<h2 id="authors">Authors</h2>
<p>Jan Hejna, 221545
Daniel Kluka, 203251</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exchange_signature_keys(connection, local_signature_pub_key, is_server):
    &#34;&#34;&#34;
    Exchange signature public keys between two communication parties.

    Args:
        connection:                 Active socket connection for data exchange.
        local_signature_pub_key:    Local user&#39;s public key.
        is_server:                  Indicates if the local party is the server (True) or the client (False). If True,
                                    sends first and receives second; if False, receives first and sends second.

    Returns:
        peer_signature_pub_key: The remote party&#39;s public key, deserialized from PEM format, for verifying signatures.

    Raises:
        TypeError: If `local_signature_pub_key` is not the correct type, indicating an invalid key.

    Notes:
        Keys are transmitted in PEM format and deserialized upon receipt to maintain cryptographic integrity and
        operability.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
    &#34;&#34;&#34;
    if not isinstance(local_signature_pub_key, (ec.EllipticCurvePublicKey, ed25519.Ed25519PublicKey)):
        logger.error(&#34;Provided public key is not a valid public key object.&#34;, exc_info=True)
        raise TypeError(&#34;Provided public key is not a valid public key object.&#34;)

    local_pub_key_bytes = ECDH.serialize_pub_key(local_signature_pub_key)

    if is_server:
        # Server sends first, then receives
        connection.send(local_pub_key_bytes)
        peer_pub_key_bytes = connection.recv(1024)
        logger.info(&#34;Alice connected as server for signature exchange.&#34;)
    else:
        # Client receives first, then sends
        peer_pub_key_bytes = connection.recv(1024)
        connection.send(local_pub_key_bytes)
        logger.info(&#34;Alice connected as client for signature exchange.&#34;)

    # Convert received bytes back to public key
    peer_signature_pub_key = serialization.load_pem_public_key(peer_pub_key_bytes)
    logger.debug(&#34;Received peer signature public key.&#34;)
    return peer_signature_pub_key</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes and runs the main functionality for Alice's side of a secure chat application.</p>
<p>This function handles the setup and management of a peer-to-peer (P2P) encrypted chat session
using elliptic curve cryptography (ECC) for secure key exchange and message encryption.</p>
<h2 id="steps">Steps</h2>
<ol>
<li>Sets up Alice's identity and creates a socket for network communication.</li>
<li>Prompts the user to enter the name of the elliptic curve for key generation.</li>
<li>Prompts the user to enter the name of the algorithm for digital signature.</li>
<li>Prompts the user to enter the name encryption method for ECIES.</li>
<li>Prompts the user to enter the new file password for file encryption.</li>
<li>Attempts to establish a connection with Bob:<ul>
<li>If a connection is not initially established, it assumes the role of server and waits for a client.</li>
<li>If connected, it assumes the role of client.</li>
</ul>
</li>
<li>Exchanges public keys and establishes encryption parameters including encryptor and decryptor.</li>
<li>Starts separate threads for sending and receiving encrypted messages or files.</li>
<li>Waits for both threads to finish, which occurs when the chat session ends.</li>
<li>Closes the network socket and prints a message indicating the end of the chat.</li>
<li>Saves log that was created during peer to peer communication.</li>
</ol>
<p>The user is responsible for specifying the correct elliptic curve name that must be agreed upon by both peers.
The user is also responsible for choosing algorithm of digital signature, encryption method and file password,
which must be agreed on the same way.</p>
<h2 id="authors">Authors</h2>
<p>Jan Hejna, 221545
Daniel Kluka, 203251
Jan Rezek, 227374
Michal Rosa, 221012</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Initializes and runs the main functionality for Alice&#39;s side of a secure chat application.

    This function handles the setup and management of a peer-to-peer (P2P) encrypted chat session
    using elliptic curve cryptography (ECC) for secure key exchange and message encryption.

    Steps:
        1. Sets up Alice&#39;s identity and creates a socket for network communication.
        2. Prompts the user to enter the name of the elliptic curve for key generation.
        3. Prompts the user to enter the name of the algorithm for digital signature.
        4. Prompts the user to enter the name encryption method for ECIES.
        5. Prompts the user to enter the new file password for file encryption.
        6. Attempts to establish a connection with Bob:
            - If a connection is not initially established, it assumes the role of server and waits for a client.
            - If connected, it assumes the role of client.
        7. Exchanges public keys and establishes encryption parameters including encryptor and decryptor.
        8. Starts separate threads for sending and receiving encrypted messages or files.
        9. Waits for both threads to finish, which occurs when the chat session ends.
        10. Closes the network socket and prints a message indicating the end of the chat.
        11. Saves log that was created during peer to peer communication.

    The user is responsible for specifying the correct elliptic curve name that must be agreed upon by both peers.
    The user is also responsible for choosing algorithm of digital signature, encryption method and file password,
    which must be agreed on the same way.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
        Jan Rezek, 227374
        Michal Rosa, 221012
    &#34;&#34;&#34;
    print(&#34;Peer name: Alice&#34;)
    peer_name = &#34;Alice&#34;
    peer_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    peer_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    curve_name = input(&#34;Enter the ECDH curve name, must be the same for both peers (e.g., SECP384R1, SECP521R1): &#34;)
    signature_name = input(&#34;Enter algorithm for digital signature (e.g., ECDSA, EdDSA): &#34;)
    ecies_type = input(&#34;Enter encryption method for ECIES (e.g., ChaCha, AES): &#34;)
    logger.info(&#34;User selected: &#34; + curve_name + &#34;, &#34; + signature_name + &#34;, &#34; + ecies_type)

    password = input(&#34;Choose new key file password: &#34;)
    logger.info(&#34;User password for key file: &#34; + password)

    logger.info(&#34;Generating ECDH keys.&#34;)
    alice_priv_key, alice_pub_key = ECDH.generate_ecdh_keys(curve_name)
    logger.debug(&#34;Generated ECDH Alice private key and public key.&#34;)

    if not attempt_connection(peer_socket):
        # Act as server
        is_server = True
        peer_socket = create_server()
        logger.info(&#34;Server created.&#34;)
    else:
        # Connected as client
        is_server = False
        logger.info(&#34;Connected to Bob.&#34;)
        print(&#34;Connected to Bob.&#34;)

    logger.info(&#34;Exchanging ECDH keys.&#34;)
    encryptor, decryptor, bob_pub_key, alice_shared_key = exchange_keys(peer_socket, alice_priv_key, is_server)
    logger.debug(&#34;Exchanged ECDH keys.&#34;)

    logger.info(&#34;Generating and encrypting Alice&#39;s signature keys.&#34;)
    signature_private_key, signature_public_key = key_generation(signature_name, &#39;alice_priv.pem&#39;, &#39;alice_pub.pem&#39;,
                                                                 password)
    logger.debug(&#34;Generated and encrypted Alice&#39;s signature keys.&#34;)

    logger.info(&#34;Exchanging signature keys.&#34;)
    peer_signature_pub_key = exchange_signature_keys(peer_socket, signature_public_key, is_server)
    logger.debug(&#34;Exchanged signature keys.&#34;)

    logger.info(&#34;Starting receiver and sender threads.&#34;)
    receiver_thread = threading.Thread(target=receive_messages,
                                       args=(peer_socket, alice_shared_key, ecies_type, peer_signature_pub_key,
                                             signature_name))
    sender_thread = threading.Thread(target=send_messages,
                                     args=(peer_socket, peer_name, alice_shared_key, ecies_type, signature_private_key,
                                           signature_name))
    logger.info(&#34;Started receiver and sender threads.&#34;)

    receiver_thread.start()
    sender_thread.start()

    receiver_thread.join()
    sender_thread.join()

    peer_socket.close()
    print(&#34;Chat ended.&#34;)</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.receive_messages"><code class="name flex">
<span>def <span class="ident">receive_messages</span></span>(<span>connection, alice_shared_key, ecies_type, signature_pub_key, signature_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives, decrypts, and verifies encrypted messages or files over a given connection.</p>
<h2 id="parameters">Parameters</h2>
<p>connection:
The communication channel used to receive encrypted messages.
alice_shared_key:
The shared secret key derived during the cryptographic session initialization, used for
decrypting the encrypted message.
ecies_type:
The type of symmetric encryption used in the ECIES scheme (AES, ChaCha).
signature_pub_key:
Public key of other peer.
signature_name:
Specifies the type of signature scheme (ECDSA, EdDSA)</p>
<h2 id="exceptions">Exceptions</h2>
<p>General exception handling to catch and handle unexpected errors.</p>
<h2 id="authors">Authors</h2>
<p>Jan Hejna, 221545
Daniel Kluka, 203251
Jan Rezek, 227374
Michal Rosa, 221012</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive_messages(connection, alice_shared_key, ecies_type, signature_pub_key, signature_name):
    &#34;&#34;&#34;
    Receives, decrypts, and verifies encrypted messages or files over a given connection.

    Parameters:
        connection:         The communication channel used to receive encrypted messages.
        alice_shared_key:   The shared secret key derived during the cryptographic session initialization, used for
                            decrypting the encrypted message.
        ecies_type:         The type of symmetric encryption used in the ECIES scheme (AES, ChaCha).
        signature_pub_key:  Public key of other peer.
        signature_name:     Specifies the type of signature scheme (ECDSA, EdDSA)

    Exceptions:
        General exception handling to catch and handle unexpected errors.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
        Jan Rezek, 227374
        Michal Rosa, 221012
    &#34;&#34;&#34;
    separator = b&#34;||&#34;
    received_files_dir = &#34;Files/ReceivedFiles/&#34;
    os.makedirs(received_files_dir, exist_ok=True)
    while True:
        try:
            encrypted_message = connection.recv(2048)  # Suggested buffer size for adequate capacity
            logger.info(f&#34;Received encrypted message: {encrypted_message.hex()}&#34;)
            print(f&#34;Received encrypted message: {encrypted_message.hex()}&#34;)

            parts = encrypted_message.split(separator)
            if len(parts) == 3:
                nonce_iv, ciphertext, signature = parts

                # Decrypt the message
                if ecies_type == &#34;ChaCha&#34;:
                    ecies_key, hmac_key = derive_encryption_parameters(alice_shared_key)
                    message = decrypt_message_chacha(ecies_key, nonce_iv, ciphertext)
                elif ecies_type == &#34;AES&#34;:
                    aes_key, hmac_key = derive_encryption_parameters(alice_shared_key)
                    message = decrypt_message_aes(aes_key, nonce_iv, ciphertext)

                # Verify the signature
                if message and verify_signature(signature_pub_key, message, signature, signature_name):
                    logger.info(f&#34;Decrypted and verified message: {message.decode(&#39;utf-8&#39;)}&#34;)
                    print(f&#34;Decrypted and verified message: {message.decode(&#39;utf-8&#39;)}&#34;)
                else:
                    logger.error(&#34;Failed to verify message signature.&#34;)
                    print(&#34;Failed to verify message signature or message is None.&#34;)
            elif len(parts) == 2:
                # File messages assumed to be in the format: FILE::filename||filedata
                filename = parts[0].split(b&#34;::&#34;)[1].decode()
                file_data = parts[1]
                filepath = os.path.join(received_files_dir, filename)
                with open(filepath, &#39;wb&#39;) as f:
                    f.write(file_data)
                logger.info(f&#34;Received and saved file: {filename}&#34;)
                print(f&#34;Received and saved file: {filename}&#34;)
            else:
                logger.warning(&#34;Invalid message format, parts count: &#34;, len(parts))
                print(&#34;Invalid message format, parts count: &#34;, len(parts))
        except Exception as e:
            logger.error(f&#34;Connection lost. Error: {e}&#34;, exc_info=True)
            print(&#34;Connection lost. Error:&#34;, e)
            break</code></pre>
</details>
</dd>
<dt id="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.send_messages"><code class="name flex">
<span>def <span class="ident">send_messages</span></span>(<span>connection, peer_name, alice_shared_key, ecies_type, signature_priv_key, signature_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends encrypted and signed messages or files from the user over a given connection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>connection</code></strong></dt>
<dd>
<pre><code>The communication channel used to send encrypted messages.
</code></pre>
</dd>
<dt><strong><code>peer_name</code></strong></dt>
<dd>
<pre><code> Name of this peer.
</code></pre>
</dd>
<dt><strong><code>alice_shared_key</code></strong></dt>
<dd>The shared secret key derived during the cryptographic session initialization, used for
encrypting message.</dd>
<dt><strong><code>ecies_type</code></strong></dt>
<dd>
<pre><code>The type of symmetric encryption used in the ECIES scheme (AES, ChaCha).
</code></pre>
</dd>
<dt><strong><code>signature_priv_key</code></strong></dt>
<dd>Private key of this peer.</dd>
<dt><strong><code>signature_name</code></strong></dt>
<dd>
<p>Specifies the type of signature scheme (ECDSA, EdDSA)</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The function returns None as it is designed to run indefinitely until
the user decides to quit the messaging session.</p>
<h2 id="exceptions">Exceptions</h2>
<p>The function will catch and print any exceptions raised during the message
sending process, mainly focusing on connection issues.</p>
<h2 id="authors">Authors</h2>
<p>Jan Hejna, 221545
Daniel Kluka, 203251
Jan Rezek, 227374
Michal Rosa, 221012</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_messages(connection, peer_name, alice_shared_key, ecies_type, signature_priv_key, signature_name):
    &#34;&#34;&#34;
    Sends encrypted and signed messages or files from the user over a given connection.

    Args:
        connection:         The communication channel used to send encrypted messages.
        peer_name:          Name of this peer.
        alice_shared_key:   The shared secret key derived during the cryptographic session initialization, used for
                            encrypting message.
        ecies_type:         The type of symmetric encryption used in the ECIES scheme (AES, ChaCha).
        signature_priv_key: Private key of this peer.
        signature_name:     Specifies the type of signature scheme (ECDSA, EdDSA)

    Returns:
        The function returns None as it is designed to run indefinitely until
        the user decides to quit the messaging session.

    Exceptions:
        The function will catch and print any exceptions raised during the message
        sending process, mainly focusing on connection issues.

    Authors:
        Jan Hejna, 221545
        Daniel Kluka, 203251
        Jan Rezek, 227374
        Michal Rosa, 221012
    &#34;&#34;&#34;
    separator = b&#34;||&#34;
    files_to_send_dir = &#34;./Files/FilesToSend/&#34;
    received_files_dir = &#34;./Files/ReceivedFiles/&#34;
    os.makedirs(received_files_dir, exist_ok=True)

    while True:
        command = input(&#34;Enter your message or type &#39;sendFile&#39; to send a file: &#34;)
        logger.debug(f&#34;User input message: {command}&#34;)

        if command.lower() == &#39;quit&#39;:
            connection.send(b&#39;quit&#39;)
            logger.info(&#34;User initiated quit.&#34;)
            break

        if command.lower() == &#39;sendfile&#39;:
            logger.info(&#34;User wants to send file&#34;)
            filename = input(&#34;Enter the filename to send: &#34;)
            filepath = os.path.join(files_to_send_dir, filename)
            if os.path.exists(filepath):
                logger.info(f&#34;File path: {filepath}&#34;)
                with open(filepath, &#39;rb&#39;) as f:
                    file_data = f.read()
                file_message = f&#34;FILE::{filename}||&#34;.encode() + file_data
                connection.send(file_message)
                logger.info(f&#34;Sent file: {filename}&#34;)
                print(f&#34;Sent file: {filename}&#34;)
            else:
                logger.warning(f&#34;File not found: {filename}&#34;)
                print(f&#34;File not found: {filename}&#34;)
            continue

        # Encode the full message
        full_message = f&#34;{peer_name}: {command}&#34;.encode(&#39;utf-8&#39;)

        # Sign the message
        signature = sign_message(signature_priv_key, full_message, signature_name)

        # Encrypt the entire message including the signature
        if ecies_type == &#34;ChaCha&#34;:
            ecies_key, hmac_key = derive_encryption_parameters(alice_shared_key)
            nonce, encrypted_message, mac = encryption_chacha(ecies_key, hmac_key, full_message)
            final_message = nonce + separator + encrypted_message + separator + signature
        elif ecies_type == &#34;AES&#34;:
            ecies_key, hmac_key = derive_encryption_parameters(alice_shared_key)
            iv, encrypted_message, mac = encryption_aes(ecies_key, hmac_key, full_message)
            final_message = iv + separator + encrypted_message + separator + signature

        try:
            connection.send(final_message)
            logger.debug(f&#34;Sent encrypted and signed message: {encrypted_message.hex()}&#34;)
            print(f&#34;Sent encrypted message: {final_message.hex()}&#34;)
        except Exception as e:
            logger.error(f&#34;Failed to send message. Error: {e}&#34;, exc_info=True)
            print(&#34;Failed to send message. Error:&#34;, e)
            break</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer" href="index.html">Elliptic-Curves-Cryptography-project-main.PeerToPeer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.attempt_connection" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.attempt_connection">attempt_connection</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.create_encryptor_decryptor" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.create_encryptor_decryptor">create_encryptor_decryptor</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.create_server" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.create_server">create_server</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.derive_key" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.derive_key">derive_key</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.exchange_keys" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.exchange_keys">exchange_keys</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.exchange_signature_keys" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.exchange_signature_keys">exchange_signature_keys</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.main" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.main">main</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.receive_messages" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.receive_messages">receive_messages</a></code></li>
<li><code><a title="Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.send_messages" href="#Elliptic-Curves-Cryptography-project-main.PeerToPeer.Alice.send_messages">send_messages</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>